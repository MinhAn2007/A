<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body {
    margin: 0;
    background: #000;
    overflow: hidden;
    height: 100vh;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const CFG = {
  PARTICLES: 2200,       // nhiều hạt hơn để tim dày hơn
  HEART_SCALE: 22,
  FOCAL: 800,
  RISE_TIME: 3500,
  HEART_TIME: 5000,
  EXPLODE_TIME: 2200,
  GLOW: 25,
  COLOR: "#66ccff",      // màu xanh nhạt
};

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: false });
let W,H,DPR=Math.max(1.8,window.devicePixelRatio||1);

function resize(){
  W=innerWidth; H=innerHeight;
  canvas.width=W*DPR; canvas.height=H*DPR;
  canvas.style.width=W+"px"; canvas.style.height=H+"px";
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
resize();
window.addEventListener("resize",resize);

function rand(a=0,b=1){return a+(b-a)*Math.random();}

// ===== TRÁI TIM 3D =====
function createHeartParticles(count){
  const points=[];
  const layers=25;
  const maxDepth=120;
  const edgeCount=Math.floor(count*0.6);
  const innerCount=count-edgeCount;

  // viền
  for(let l=0;l<layers;l++){
    const z=(l/(layers-1)-0.5)*maxDepth*2.2;
    const scale=1-Math.abs(z)/(maxDepth*2.5);
    const pointsPerLayer=Math.floor(edgeCount/layers);
    for(let i=0;i<pointsPerLayer;i++){
      const r=0.88+0.12*Math.random();
      const t=(i/pointsPerLayer)*Math.PI*2+l*0.08;
      const x2d=16*Math.pow(Math.sin(t),3);
      const y2d=-(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
      points.push({
        x:x2d*r*scale*CFG.HEART_SCALE,
        y:y2d*r*scale*CFG.HEART_SCALE-H*0.04,
        z:z+rand(-18,18),
        isEdge:true
      });
    }
  }

  // bên trong
  for(let l=0;l<layers;l++){
    const z=(l/(layers-1)-0.5)*maxDepth*2.2;
    const scale=1-Math.abs(z)/(maxDepth*2.5);
    const pointsPerLayer=Math.floor(innerCount/layers);
    for(let i=0;i<pointsPerLayer;i++){
      const r=0.35+0.5*Math.pow(Math.random(),1.5);
      const t=(i/pointsPerLayer)*Math.PI*2+l*0.12;
      const x2d=16*Math.pow(Math.sin(t),3);
      const y2d=-(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t));
      points.push({
        x:x2d*r*scale*CFG.HEART_SCALE,
        y:y2d*r*scale*CFG.HEART_SCALE-H*0.04,
        z:z+rand(-22,22),
        isEdge:false
      });
    }
  }
  return points;
}

// ===== PARTICLE =====
class Particle{
  constructor(target){
    this.target=target;
    this.tx=target.x; this.ty=target.y; this.tz=target.z;
    this.size=rand(1.6,3.8);
    this.reset();
  }
  reset(){
    this.x=rand(-W*0.45,W*0.45);
    this.y=H*0.48 + rand(H*0.18,H*0.38);
    this.z=rand(-150,150);
    this.alpha=0;
  }
  project(){
    const scale=CFG.FOCAL/(CFG.FOCAL+this.z+30);
    return {sx:this.x*scale+W/2, sy:this.y*scale+H/2, s:this.size*scale*(1+this.z/700)};
  }
  draw(){
    const {sx,sy,s}=this.project();
    if(s<0.4) return;
    ctx.save();
    // glow nhấp nháy nhẹ
    const glow = CFG.GLOW + Math.sin(performance.now()*0.01+this.x)*6;
    ctx.globalAlpha=Math.min(1,this.alpha);
    ctx.shadowBlur=glow+s*2;
    ctx.shadowColor=CFG.COLOR;
    ctx.fillStyle=CFG.COLOR;
    ctx.beginPath();
    ctx.arc(sx,sy,s*1.2,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

// ===== MAIN =====
let particles=[], targets=[], stage="rise", t0=performance.now();

function init(){
  targets=createHeartParticles(CFG.PARTICLES);
  particles=targets.map(t=>{
    const p=new Particle(t);
    p.tx=t.x; p.ty=t.y; p.tz=t.z;
    return p;
  });
  stage="rise"; t0=performance.now();
}
init();

function loop(now){
  const elapsed=now-t0;
  ctx.fillStyle="rgba(0,0,0,0.10)";
  ctx.fillRect(0,0,W,H);

  // xử lý tim
  if(stage==="rise"){
    const p=Math.min(1, elapsed/CFG.RISE_TIME);
    particles.forEach(pt=>{
      pt.x+=(pt.tx-pt.x)*0.05*p;
      pt.y+=(pt.ty-pt.y)*0.05*p;
      pt.z+=(pt.tz-pt.z)*0.05*p;
      pt.alpha=p;
    });
    if(p>=1){ stage="heart"; t0=now; }
  } else if(stage==="heart"){
    const p=elapsed/CFG.HEART_TIME;
    const rotY=p*Math.PI*1.2;
    const rotX=Math.sin(p*Math.PI)*0.35;
    const heartBeat=1+0.16*Math.sin(now*0.005); // tim phồng nhịp tự nhiên
    particles.forEach(pt=>{
      let x=pt.tx*Math.cos(rotY)-pt.tz*Math.sin(rotY);
      let z=pt.tx*Math.sin(rotY)+pt.tz*Math.cos(rotY);
      let y=pt.ty;
      y=pt.ty*Math.cos(rotX)-z*Math.sin(rotX);
      z=pt.ty*Math.sin(rotX)+z*Math.cos(rotX);
      x*=heartBeat; y*=heartBeat; z*=heartBeat*0.95;
      pt.x+=(x-pt.x)*0.2;
      pt.y+=(y-pt.y)*0.2;
      pt.z+=(z-pt.z)*0.2;
      pt.alpha=1;
    });
    if(p>=1){ stage="explode"; t0=now; }
  } else if(stage==="explode"){
    particles.forEach(pt=>{
      if(!pt.v){
        const force=rand(14,28);
        const ang=rand(0,Math.PI*2);
        const up=rand(0.4,1);
        pt.vx=Math.cos(ang)*force;
        pt.vy=-up*force*1.6;
        pt.vz=Math.sin(ang)*force*0.8;
        pt.v=true;
      }
      pt.vy+=0.55;
      pt.x+=pt.vx; pt.y+=pt.vy; pt.z+=pt.vz;
      pt.alpha-=0.022; if(pt.alpha<0) pt.alpha=0;
    });
    if(elapsed>CFG.EXPLODE_TIME) init();
  }

  particles.sort((a,b)=>b.z-a.z);
  particles.forEach(p=>p.draw());
  requestAnimationFrame(loop);
}

canvas.addEventListener("pointerdown", ()=>{
  if(stage==="heart"){ stage="explode"; t0=performance.now(); }
});

requestAnimationFrame(loop);
</script>
</body>
</html>
